# -*- coding: utf-8 -*-
"""mitnop.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1USeM-yRQFkwmsblIssIb7eqpkZHgba72
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
# %cd /content/drive/My Drive/mitnop datasets/

# Ilija Vitošević IN15/2021

#%% Biblioteke

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

#%% Ucitavanje podataka i pocetno upoznavanje

#df = pd.read_csv('flag.data')
df = pd.read_csv('flags_csv/flag.data', names=[
    'name', 'landmass', 'zone', 'area', 'population', 'language',
    'religion', 'bars', 'stripes', 'colours', 'red', 'green', 'blue',
    'gold', 'white', 'black', 'orange', 'mainhue', 'circles', 'crosses',
    'saltires', 'quarters', 'sunstars', 'crescent', 'triangle', 'icon',
    'animate', 'text', 'topleft', 'botright'])

print('Skup podataka:')
print(df)

print('\nTipovi kolona:')
print(df.dtypes)

print('\nDimenzije df-a:')
print(df.shape)

print('\nProvera da li postoje nedostajuce vrednosti:')
print(df.isna().sum())

#%% 1. Analiza distribucija nekih varijabli

#%% Distribucija language po broju zemalja

plt.figure(figsize=(8, 5))
sns.countplot(data=df, x='language', edgecolor='black', linewidth=2, palette='Spectral')
plt.title('Distribucija jezika')
plt.xlabel('Jezik')
plt.ylabel('Broj zemalja')
plt.ylim(0, 50)
plt.xticks(ticks=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
           labels=['English', 'Spanish', 'French', 'German', 'Slavic', 'Other\n Indo-European', 'Chinese', 'Arabic', 'Japanese/Turkish/\nFinnish/Magyar', 'Others'],
           rotation=75)

#%% Distribucija mainhue (dominantna boja) po broju zemalja

colors = {'green': 'green', 'red' : 'red', 'blue': 'blue', 'gold': 'gold',
          'white': 'white', 'orange': 'orange', 'black': 'black', 'brown': 'brown'}
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='mainhue', palette=colors.keys(), edgecolor='black', linewidth=2)
plt.title('Distribucija dominantne boja')
plt.xlabel('Dominantna boja')
plt.ylabel('Broj zemalja')
plt.xticks(rotation=45)

#%% Distribucija broja boja na zastavama po broju zemalja

plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='colours', edgecolor='black', linewidth=2, palette='Set1')
plt.title('Distribucija broja boja na zastavama')
plt.xlabel('Broj boja')
plt.ylabel('Broj zemalja')
plt.show()

#%% Distribucija religion po broju zemalja

plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='religion', edgecolor='black', linewidth=2, palette='Set1')
plt.title('Distribucija religija po zemljama')
plt.xlabel('Religija')
plt.ylabel('Broj zemalja')
plt.ylim(0, 50)
plt.xticks(ticks=[0, 1, 2, 3, 4, 5, 6, 7],
           labels=['Chatolic', 'Other Christian', 'Muslim', 'Buddhist', 'Hindu', 'Ethnic', 'Marxist', 'Others'],
           rotation=75)

#%% Binarna analiza frekvencije boja, sve na jednom mestu

color_features = ['red', 'green', 'blue', 'gold', 'white', 'black', 'orange']
plt.figure(figsize=(12, 8))

for i, feature in enumerate(color_features, 1):
    plt.subplot(2, 4, i)
    sns.countplot(data=df, x=feature, edgecolor='black', linewidth=2, palette=['orange', 'blue'])
    plt.title(f'Ucestalost boje: "{feature}"')
    plt.ylabel('Broj zemalja')
    plt.xlabel('')
    plt.ylim(0, 170)
    plt.xticks(ticks=[0, 1], labels=['Nema', 'Ima'])

plt.tight_layout()
plt.show()


#%% 2. Poredjenje atributa izmedju klasa

#%% Uporedni pregled:
#bars = vertikalne pruge, koje religije imaju koliko zastava sa n brojem vertikalnih pruga
#stipes = horizontalne pruge
#colors = broj boja na zastavi
#circles = broj krugova na zastavi
#crosses = broj krstova na zastavi
#sunstars = broj sunaca i zvezdi na zastavi

# Definisanje legendi za religije
religion_labels = {
    0: 'Catholic',
    1: 'Other Christian',
    2: 'Muslim',
    3: 'Buddhist',
    4: 'Hindu',
    5: 'Ethnic',
    6: 'Marxist',
    7: 'Others'
}

target_variable = 'religion'
compare_features = ['bars', 'stripes', 'colours', 'circles', 'crosses', 'sunstars']

for feature in compare_features:
    plt.figure(figsize=(8, 5))
    ax = sns.countplot(data=df, x=feature, hue=target_variable, edgecolor='black', linewidth=1.5, palette='Set1')

    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles, [religion_labels[int(label)] for label in labels], title='Religion', loc='upper right')

    plt.title(f'Poredjenje "{feature}" sa "{target_variable}"')
    plt.xlabel(feature)
    plt.ylabel('Broj zemalja')
    plt.show()


#%% Učestalost nekih osobina (ako zatreba provera)
feature = 'red'
red_frequency = df[feature].value_counts()
print(f"Učestalost osobine {feature}:")
print(red_frequency)


#%% Mainhue(dominantna boja) po landamss(kontinenti) i po area(meridijan-ekvator)

df = pd.read_csv('flags_csv/flag.data', names=[
    'name', 'landmass', 'zone', 'area', 'population', 'language',
    'religion', 'bars', 'stripes', 'colours', 'red', 'green', 'blue',
    'gold', 'white', 'black', 'orange', 'mainhue', 'circles', 'crosses',
    'saltires', 'quarters', 'sunstars', 'crescent', 'triangle', 'icon',
    'animate', 'text', 'topleft', 'botright'])

# Mapiranje za geografske karakteristike
landmass_map = {1: 'N.America', 2: 'S.America', 3: 'Europe', 4: 'Africa', 5: 'Asia', 6: 'Oceania'}
zone_map = {1: 'NE', 2: 'SE', 3: 'SW', 4: 'NW'}

# Zamena vrednosti u DataFrame-u
df['landmass'] = df['landmass'].map(landmass_map)
df['zone'] = df['zone'].map(zone_map)

regional_features = ['landmass', 'zone']
for feature in regional_features:
    plt.figure(figsize=(10, 6))
    palette = {hue: hue for hue in df['mainhue'].unique()}
    sns.countplot(data=df, x=feature, hue='mainhue', palette=palette, edgecolor='black', linewidth=2)
    plt.title(f'Dominantna boja po regionima za "{feature}"')
    plt.xlabel(feature)
    plt.ylabel('Broj zemalja')
    plt.show()

#%% Jezik po regionima

df = pd.read_csv('flags_csv/flag.data', names=[
    'name', 'landmass', 'zone', 'area', 'population', 'language',
    'religion', 'bars', 'stripes', 'colours', 'red', 'green', 'blue',
    'gold', 'white', 'black', 'orange', 'mainhue', 'circles', 'crosses',
    'saltires', 'quarters', 'sunstars', 'crescent', 'triangle', 'icon',
    'animate', 'text', 'topleft', 'botright'])

landmass_map = {1: 'N.America', 2: 'S.America', 3: 'Europe', 4: 'Africa', 5: 'Asia', 6: 'Oceania'}
zone_map = {1: 'NE', 2: 'SE', 3: 'SW', 4: 'NW'}

df['landmass'] = df['landmass'].map(landmass_map)
df['zone'] = df['zone'].map(zone_map)

language_map = {
    1: 'English', 2: 'Spanish', 3: 'French', 4: 'German', 5: 'Slavic', 6: 'Other Indo-European',
    7: 'Chinese', 8: 'Arabic', 9: 'Japanese/Turkish/Finnish/Magyar', 10: 'Others'
}

df['language'] = df['language'].map(language_map)

regional_features = ['landmass', 'zone']
for feature in regional_features:
    plt.figure(figsize=(12, 8))
    sns.countplot(data=df, x=feature, hue='language', edgecolor='black', linewidth=2)
    plt.title(f'Jezik po regionima za "{feature}"')
    plt.xlabel(feature)
    plt.ylabel('Broj zemalja')
    plt.legend(title='Jezik', bbox_to_anchor=(0.5, 0.6))
    plt.show()

#%% Religija po regionima

df = pd.read_csv('flags_csv/flag.data', names=[
    'name', 'landmass', 'zone', 'area', 'population', 'language',
    'religion', 'bars', 'stripes', 'colours', 'red', 'green', 'blue',
    'gold', 'white', 'black', 'orange', 'mainhue', 'circles', 'crosses',
    'saltires', 'quarters', 'sunstars', 'crescent', 'triangle', 'icon',
    'animate', 'text', 'topleft', 'botright'])

landmass_map = {1: 'N.America', 2: 'S.America', 3: 'Europe', 4: 'Africa', 5: 'Asia', 6: 'Oceania'}
zone_map = {1: 'NE', 2: 'SE', 3: 'SW', 4: 'NW'}

df['landmass'] = df['landmass'].map(landmass_map)
df['zone'] = df['zone'].map(zone_map)

religion_map = {
    0: 'Catholic', 1: 'Other Christian', 2: 'Muslim', 3: 'Buddhist', 4: 'Hindu',
    5: 'Ethnic', 6: 'Marxist', 7: 'Others'
}

df['religion'] = df['religion'].map(religion_map)

regional_features = ['landmass', 'zone']
for feature in regional_features:
    plt.figure(figsize=(12, 8))
    sns.countplot(data=df, x=feature, hue='religion', edgecolor='black', linewidth=2)
    plt.title(f'Religija po regionima za "{feature}"')
    plt.xlabel(feature)
    plt.ylabel('Broj instanci')
    plt.legend(title='Religija')
    plt.show()


#%% Dominantna boja zastave po religiji

df = pd.read_csv('flags_csv/flag.data', names=[
    'name', 'landmass', 'zone', 'area', 'population', 'language',
    'religion', 'bars', 'stripes', 'colours', 'red', 'green', 'blue',
    'gold', 'white', 'black', 'orange', 'mainhue', 'circles', 'crosses',
    'saltires', 'quarters', 'sunstars', 'crescent', 'triangle', 'icon',
    'animate', 'text', 'topleft', 'botright'])

palette = {
    'green': 'green',
    'red': 'red',
    'blue': 'blue',
    'gold': 'gold',
    'white': 'white',
    'black': 'black',
    'orange': 'orange',
    'brown': 'brown'
}

religion_map = {
    0: 'Catholic',
    1: 'Other Christian',
    2: 'Muslim',
    3: 'Buddhist',
    4: 'Hindu',
    5: 'Ethnic',
    6: 'Marxist',
    7: 'Others'
}

df['religion'] = df['religion'].map(religion_map)

plt.figure(figsize=(12, 8))
sns.countplot(data=df, x='religion', hue='mainhue', palette=palette, edgecolor='black', linewidth=2)
plt.title('Dominantna boja zastave prema religiji')
plt.xlabel('Religija')
plt.ylabel('Broj zemalja')
plt.legend(title='Dominantna boja', loc='upper right')
plt.xticks(rotation=45, ha='right')
plt.show()

#%% Dominantna boja zastave po jeziku

df = pd.read_csv('flags_csv/flag.data', names=[
    'name', 'landmass', 'zone', 'area', 'population', 'language',
    'religion', 'bars', 'stripes', 'colours', 'red', 'green', 'blue',
    'gold', 'white', 'black', 'orange', 'mainhue', 'circles', 'crosses',
    'saltires', 'quarters', 'sunstars', 'crescent', 'triangle', 'icon',
    'animate', 'text', 'topleft', 'botright'])

palette = {
    'green': 'green',
    'red': 'red',
    'blue': 'blue',
    'gold': 'gold',
    'white': 'white',
    'black': 'black',
    'orange': 'orange',
    'brown': 'brown'
}

plt.figure(figsize=(12, 8))
sns.countplot(data=df, x='language', hue='mainhue', palette=palette, edgecolor='black', linewidth=2)
plt.title('Dominantna boja zastave prema jeziku')
plt.xlabel('Jezik')
plt.ylabel('Broj zemalja')

plt.xticks(ticks=range(10),
           labels=['English', 'Spanish', 'French', 'German', 'Slavic', 'Other\n Indo-European', 'Chinese', 'Arabic', 'Japanese/Turkish/\nFinnish/Magyar', 'Others'],
           rotation=45, ha='right')

plt.legend(title='Dominantna boja')
plt.show()

#%% 3. Korelaciona analiza

numerical_features = ['area', 'population', 'bars', 'stripes', 'colours', 'red', 'green', 'blue', 'gold', 'white',
                      'black', 'orange', 'circles', 'crosses', 'saltires', 'quarters', 'sunstars', 'crescent',
                      'triangle', 'icon', 'animate', 'text']

plt.figure(figsize=(16, 14))
sns.heatmap(df[numerical_features].corr(), annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Korelacija numeričkih varijabli')
plt.show()

#Zaključci:
#area i population -> vece zemlje imaju vece populacije
#area i sunstars -> veca povrsina imace vise zvezdi i sunaca na zastavi
#bars i stripes -> ima jednih, nece biti drugih
#bars i white -> vertikalne pruge i bela boja se ne slazu
#colors i red/green/gold/orange/icon/animate/text -> vise boja, pa pojavice se i crvena/zelena/zuta/narandzasta/slicica/tekst
#green i blue -> iskljucuju jedna drugu
#blue i white -> ocekuju jedna drugu
#blue i black -> iskljucuju jedna drugu
#gold i animte/icon -> ocekuju jedni druge
#gold i white -> iskljucuju se
#crosses i saltiers -> ocekuju se

# Marko Kolarski IN60/2021

import os
import cv2
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from tensorflow.keras import layers, models
from tensorflow.keras.regularizers import l2
from tensorflow.keras.initializers import glorot_uniform
import matplotlib.pyplot as plt
import random
import tensorflow as tf


os.environ["TF_ENABLE_ONEDNN_OPTS"] = "0"
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'


# Putanje do podataka
FLAG_IMAGES_PATH = 'flag_images'
FLAGS_CSV_PATH = 'flags_csv/flag.data'

# Učitavanje podataka iz CSV-a
df = pd.read_csv(FLAGS_CSV_PATH, names=[
    'name', 'landmass', 'zone', 'area', 'population', 'language',
    'religion', 'bars', 'stripes', 'colours', 'red', 'green', 'blue',
    'gold', 'white', 'black', 'orange', 'mainhue', 'circles', 'crosses',
    'saltires', 'quarters', 'sunstars', 'crescent', 'triangle', 'icon',
    'animate', 'text', 'topleft', 'botright'
])

# Mapiranje naziva datoteka na nazive zemalja
FILENAME_TO_COUNTRY = {
    f"{name.replace(' ', '_')}.png": name
    for name in df['name']
}

# Učitavanje i predobrada slika
images = []
for idx, row in df.iterrows():
    filename = f"{row['name'].replace(' ', '_')}.png"
    if filename in FILENAME_TO_COUNTRY and FILENAME_TO_COUNTRY[filename] == row['name']:
        img_path = os.path.join(FLAG_IMAGES_PATH, filename)
        img = cv2.imread(img_path)
        if img is not None:
            img = cv2.resize(img, (305, 121))
            images.append(img)
        else:
            print(f"Upozorenje: Nije moguće učitati sliku za {row['name']}")
    else:
        print(f"Upozorenje: Nije pronađena slika za {row['name']}")

# Provjera usklađenosti broja slika i redova u DataFrame-u
if len(images) == len(df):
    df['image'] = images
else:
     print(f"Upozorenje: Broj slika ({len(images)}) ne odgovara broju redova u DataFrame-u ({len(df)})")

REGION_MAPPING = {
    "Africa": ["Algeria", "Angola", "Benin", "Botswana", "Burkina", "Burundi", "Cameroon", "Cape-Verde-Islands", "Central-African-Republic", "Chad", "Comorro-Islands", "Congo", "Djibouti", "Egypt", "Equatorial-Guinea", "Ethiopia", "Gabon", "Gambia", "Ghana", "Guinea", "Guinea-Bissau", "Kenya", "Lesotho", "Liberia", "Libya", "Madagascar", "Malawi", "Mali", "Mauritania", "Mauritius", "Morocco", "Mozambique", "Namibia", "Niger", "Nigeria", "Rwanda", "Senegal", "Seychelles", "Sierra-Leone", "Somalia", "South-Africa", "Sudan", "Swaziland", "Tanzania", "Togo", "Tunisia", "Uganda", "Zaire", "Zambia", "Zimbabwe"],
    "Rest of the World": ["Canada", "USA", "Mexico", "Argentine", "Bolivia", "Brazil", "Chile", "Colombia", "Ecuador", "Guyana", "Paraguay", "Peru", "Surinam", "Uruguay", "Venezuela", "Albania", "Andorra", "Austria", "Belgium", "Bulgaria", "Cyprus", "Czechoslovakia", "Denmark", "Finland", "France", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Italy", "Liechtenstein", "Luxembourg", "Malta", "Monaco", "Netherlands", "Norway", "Poland", "Portugal", "Romania", "San-Marino", "Spain", "Sweden", "Switzerland", "Turkey", "UK", "Yugoslavia", "Afghanistan", "Bahrain", "Bangladesh", "Bhutan", "Brunei", "Burma", "Cambodia", "China", "India", "Indonesia", "Iran", "Iraq", "Israel", "Japan", "Jordan", "Korea-North", "Korea-South", "Kuwait", "Laos", "Lebanon", "Malaysia", "Maldive-Islands", "Mongolia", "Nepal", "Oman", "Pakistan", "Philippines", "Qatar", "Saudi-Arabia", "Singapore", "Sri-Lanka", "Syria", "Taiwan", "Thailand", "United-Arab-Emirates", "Vietnam", "Yemen-North", "Yemen-South", "Australia", "Fiji", "Kiribati", "Micronesia", "Nauru", "New-Zealand", "Papua-New-Guinea", "Solomon-Islands", "Tonga", "Tuvalu", "Vanuatu", "Guam", "American-Samoa", "Cook-Islands", "French-Polynesia", "Niue"]
}

# # Definisanje regija za zemlje
# REGION_MAPPING = {
#     "Africa": ["Algeria", "Angola", "Benin", "Botswana", "Burkina", "Burundi", "Cameroon", "Cape-Verde-Islands", "Central-African-Republic", "Chad", "Comorro-Islands", "Congo", "Djibouti", "Egypt", "Equatorial-Guinea", "Ethiopia", "Gabon", "Gambia", "Ghana", "Guinea", "Guinea-Bissau", "Kenya", "Lesotho", "Liberia", "Libya", "Madagascar", "Malawi", "Mali", "Mauritania", "Mauritius", "Morocco", "Mozambique", "Namibia", "Niger", "Nigeria", "Rwanda", "Senegal", "Seychelles", "Sierra-Leone", "Somalia", "South-Africa", "Sudan", "Swaziland", "Tanzania", "Togo", "Tunisia", "Uganda", "Zaire", "Zambia", "Zimbabwe"],
#     "America": ["Canada", "USA", "Mexico", "Argentine", "Bolivia", "Brazil", "Chile", "Colombia", "Ecuador", "Guyana", "Paraguay", "Peru", "Surinam", "Uruguay", "Venezuela"],
#     "Europe": ["Albania", "Andorra", "Austria", "Belgium", "Bulgaria", "Cyprus", "Czechoslovakia", "Denmark", "Finland", "France", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Italy", "Liechtenstein", "Luxembourg", "Malta", "Monaco", "Netherlands", "Norway", "Poland", "Portugal", "Romania", "San-Marino", "Spain", "Sweden", "Switzerland", "Turkey", "UK", "Yugoslavia"],
#     "Asia": ["Afghanistan", "Bahrain", "Bangladesh", "Bhutan", "Brunei", "Burma", "Cambodia", "China", "India", "Indonesia", "Iran", "Iraq", "Israel", "Japan", "Jordan", "Korea-North", "Korea-South", "Kuwait", "Laos", "Lebanon", "Malaysia", "Maldive-Islands", "Mongolia", "Nepal", "Oman", "Pakistan", "Philippines", "Qatar", "Saudi-Arabia", "Singapore", "Sri-Lanka", "Syria", "Taiwan", "Thailand", "United-Arab-Emirates", "Vietnam", "Yemen-North", "Yemen-South"],
#     "Oceania": ["Australia", "Fiji", "Kiribati", "Micronesia", "Nauru", "New-Zealand", "Papua-New-Guinea", "Solomon-Islands", "Tonga", "Tuvalu", "Vanuatu", "Guam", "American-Samoa", "Cook-Islands", "French-Polynesia", "Niue"]
# }

# Mapiranje religija
RELIGION_MAPPING = {
    0: "Catholic",
    1: "Other Christian",
    2: "Muslim",
    3: "Buddhist",
    4: "Hindu",
    5: "Ethnic",
    6: "Marxist",
    7: "Others"
}

# Grupisanje podataka po regijama
grouped_data = {
    region: df[df['name'].isin(countries)]
    for region, countries in REGION_MAPPING.items()
}

SEED = 42
random.seed(SEED)
np.random.seed(SEED)
tf.random.set_seed(SEED)


# Podela podataka na train, validation i test skupove po regijama
def split_data(grouped_data):
    train_data, validation_data, test_data = {}, {}, {}
    for region, data in grouped_data.items():
        train_validation, test = train_test_split(data, test_size=0.1, random_state=SEED)
        train, validation = train_test_split(train_validation, test_size=0.2222, random_state=SEED)
        train_data[region] = train
        validation_data[region] = validation
        test_data[region] = test
    return train, train_data, validation_data, test_data

train, train_data, validation_data, test_data = split_data(grouped_data)


# Definisanje CNN arhitekture sa regularizacijom i dropout slojevima
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', kernel_regularizer=l2(0.001)),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.25),
    layers.Conv2D(64, (3, 3), activation='relu', kernel_regularizer=l2(0.001)),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.25),
    layers.Conv2D(128, (3, 3), activation='relu', kernel_regularizer=l2(0.001)),
    layers.MaxPooling2D((2, 2)),
    layers.Dropout(0.25),
    layers.Flatten(),
    layers.Dense(128, activation='relu', kernel_regularizer=l2(0.001), kernel_initializer=glorot_uniform(seed=SEED)),
    layers.Dropout(0.5),
    layers.Dense(256, input_dim=train.shape[1], activation='relu', kernel_initializer=glorot_uniform(seed=SEED)),
    layers.Dense(256, activation='relu', kernel_initializer=glorot_uniform(seed=SEED)),
    layers.Dense(8, activation='softmax', kernel_initializer=glorot_uniform(seed=SEED))
])

# Kompajliranje modela sa različitim optimizerom i hiperparametrima
model.compile(optimizer='rmsprop', loss='sparse_categorical_crossentropy', metrics=['accuracy'])


# Treniranje modela
for region, train_set in train_data.items():
    train_images = np.array(train_set['image'].tolist()) / 255.0
    train_labels = np.array(train_set['religion'])

    validation_set = validation_data[region]
    validation_images = np.array(validation_set['image'].tolist()) / 255.0
    validation_labels = np.array(validation_set['religion'])

    test_set = test_data[region]
    test_images = np.array(test_set['image'].tolist()) / 255.0
    test_labels = np.array(test_set['religion'])

    print(f"Jedinstvene oznake vrednosti za {region}: {[RELIGION_MAPPING[label] for label in sorted(train_set['religion'].unique())]}")

    # Treniranje modela sa većim brojem epoha i validacionim podacima
    history = model.fit(train_images, train_labels, epochs=20, validation_data=(validation_images, validation_labels))

    # Postavljanje veličine figure
    plt.figure(figsize=(12, 5))

    # Plot tačnosti
    plt.subplot(1, 2, 1)
    plt.plot(history.history['accuracy'], label='Tačnost treniranja', color='blue', linewidth=2)
    plt.plot(history.history['val_accuracy'], label='Tačnost validacije', color='orange', linewidth=2)
    plt.xlabel('Epoha', fontsize=14)
    plt.ylabel('Tačnost', fontsize=14)
    plt.legend(loc='upper right', fontsize=12)
    plt.title('Tačnost modela tokom treniranja', fontsize=16)
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.ylim([0, 1])

    # Plot gubitka
    plt.subplot(1, 2, 2)
    plt.plot(history.history['loss'], label='Gubitak treniranja', color='blue', linewidth=2)
    plt.plot(history.history['val_loss'], label='Gubitak validacije', color='orange', linewidth=2)
    plt.xlabel('Epoha', fontsize=14)
    plt.ylabel('Gubitak', fontsize=14)
    plt.legend(loc='upper right', fontsize=12)
    plt.title('Gubitak modela tokom treniranja', fontsize=16)
    plt.grid(True, linestyle='--', alpha=0.7)

    plt.tight_layout(pad=3)
    plt.show()

    # Evaluacija modela
    test_loss, test_acc = model.evaluate(test_images, test_labels)
    print(f'Test tačnost za {region}: {test_acc:.2f}')

    # Predikcije na test podacima
    predictions = model.predict(test_images)
    predicted_labels = np.argmax(predictions, axis=1)

    # Ispis stvarnih i predviđenih religija za svaki test podatak
    print(f"{'Test Uzorak':>15} | {'Zemlja':>20} | {'Stvarna Religija':>20} | {'Predviđena Religija':>20}")
    print("-" * 90)
    for i in range(len(test_labels)):
        actual_religion = RELIGION_MAPPING[test_labels[i]]
        predicted_religion = RELIGION_MAPPING[predicted_labels[i]]

        # Pronalaženje naziva države za odgovarajući test uzorak
        country_name = test_set.iloc[i]['name']

        print(f"{i+1:>15} | {country_name:>20} | {actual_religion:>20} | {predicted_religion:>20}")
    print()

# Srđan Garić IN47/2021 IMG

import os
import cv2
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from tensorflow.keras import applications
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.utils import to_categorical
import matplotlib.pyplot as plt
import random
import tensorflow as tf

os.environ["TF_ENABLE_ONEDNN_OPTS"] = "0"
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

# Putanje do podataka
FLAG_IMAGES_PATH = 'flag_images'
FLAGS_CSV_PATH = 'flags_csv/flag.data'

# Učitavanje podataka iz CSV-a
df = pd.read_csv(FLAGS_CSV_PATH, names=[
    'name', 'landmass', 'zone', 'area', 'population', 'language',
    'religion', 'bars', 'stripes', 'colours', 'red', 'green', 'blue',
    'gold', 'white', 'black', 'orange', 'mainhue', 'circles', 'crosses',
    'saltires', 'quarters', 'sunstars', 'crescent', 'triangle', 'icon',
    'animate', 'text', 'topleft', 'botright'
])

# Mapiranje naziva datoteka na nazive zemalja
FILENAME_TO_COUNTRY = {
    f"{name.replace(' ', '_')}.png": name
    for name in df['name']
}

# Učitavanje i predobrada slika
images = []
for idx, row in df.iterrows():
    filename = f"{row['name'].replace(' ', '_')}.png"
    if filename in FILENAME_TO_COUNTRY and FILENAME_TO_COUNTRY[filename] == row['name']:
        img_path = os.path.join(FLAG_IMAGES_PATH, filename)
        img = cv2.imread(img_path)
        if img is not None:
            img = cv2.resize(img, (224, 224))
            images.append(img)
        else:
            print(f"Upozorenje: Nije moguće učitati sliku za {row['name']}")
    else:
        print(f"Upozorenje: Nije pronađena slika za {row['name']}")

# Provjera usklađenosti broja slika i redova u DataFrame-u
if len(images) == len(df):
    df['image'] = images
else:
     print(f"Upozorenje: Broj slika ({len(images)}) ne odgovara broju redova u DataFrame-u ({len(df)})")

REGION_MAPPING = {
    "Africa": ["Algeria", "Angola", "Benin", "Botswana", "Burkina", "Burundi", "Cameroon", "Cape-Verde-Islands", "Central-African-Republic", "Chad", "Comorro-Islands", "Congo", "Djibouti", "Egypt", "Equatorial-Guinea", "Ethiopia", "Gabon", "Gambia", "Ghana", "Guinea", "Guinea-Bissau", "Kenya", "Lesotho", "Liberia", "Libya", "Madagascar", "Malawi", "Mali", "Mauritania", "Mauritius", "Morocco", "Mozambique", "Namibia", "Niger", "Nigeria", "Rwanda", "Senegal", "Seychelles", "Sierra-Leone", "Somalia", "South-Africa", "Sudan", "Swaziland", "Tanzania", "Togo", "Tunisia", "Uganda", "Zaire", "Zambia", "Zimbabwe"],
    "Rest of the World": ["Canada", "USA", "Mexico", "Argentine", "Bolivia", "Brazil", "Chile", "Colombia", "Ecuador", "Guyana", "Paraguay", "Peru", "Surinam", "Uruguay", "Venezuela", "Albania", "Andorra", "Austria", "Belgium", "Bulgaria", "Cyprus", "Czechoslovakia", "Denmark", "Finland", "France", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Italy", "Liechtenstein", "Luxembourg", "Malta", "Monaco", "Netherlands", "Norway", "Poland", "Portugal", "Romania", "San-Marino", "Spain", "Sweden", "Switzerland", "Turkey", "UK", "Yugoslavia", "Afghanistan", "Bahrain", "Bangladesh", "Bhutan", "Brunei", "Burma", "Cambodia", "China", "India", "Indonesia", "Iran", "Iraq", "Israel", "Japan", "Jordan", "Korea-North", "Korea-South", "Kuwait", "Laos", "Lebanon", "Malaysia", "Maldive-Islands", "Mongolia", "Nepal", "Oman", "Pakistan", "Philippines", "Qatar", "Saudi-Arabia", "Singapore", "Sri-Lanka", "Syria", "Taiwan", "Thailand", "United-Arab-Emirates", "Vietnam", "Yemen-North", "Yemen-South", "Australia", "Fiji", "Kiribati", "Micronesia", "Nauru", "New-Zealand", "Papua-New-Guinea", "Solomon-Islands", "Tonga", "Tuvalu", "Vanuatu", "Guam", "American-Samoa", "Cook-Islands", "French-Polynesia", "Niue"]
}

# Mapiranje religija
RELIGION_MAPPING = {
    0: "Catholic",
    1: "Other Christian",
    2: "Muslim",
    3: "Buddhist",
    4: "Hindu",
    5: "Ethnic",
    6: "Marxist",
    7: "Others"
}

# Grupisanje podataka po regijama
grouped_data = {
    region: df[df['name'].isin(countries)]
    for region, countries in REGION_MAPPING.items()
}

SEED = 42
random.seed(SEED)
np.random.seed(SEED)
tf.random.set_seed(SEED)

# Podela podataka na train, validation i test skupove po regijama
def split_data(grouped_data):
    train_data, validation_data, test_data = {}, {}, {}
    for region, data in grouped_data.items():
        train_validation, test = train_test_split(data, test_size=0.1, random_state=42)
        train, validation = train_test_split(train_validation, test_size=0.2222, random_state=42)
        train_data[region] = train
        validation_data[region] = validation
        test_data[region] = test
    return train, train_data, validation_data, test_data

train, train_data, validation_data, test_data = split_data(grouped_data)

# Definisanje modela
base_model = applications.MobileNetV2(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
base_model.trainable = False
inputs = tf.keras.Input(shape=(224, 224, 3))
x = base_model(inputs, training=False)
x = GlobalAveragePooling2D()(x)
x = Dense(128, activation='relu')(x)
outputs = Dense(8, activation='softmax')(x)
model = Model(inputs, outputs)
model.compile(optimizer=Adam(learning_rate=1e-4), loss='categorical_crossentropy', metrics=['accuracy'])

# Treniranje modela
for region, train_set in train_data.items():
    train_images = np.array(train_set['image'].tolist()) / 255.0
    train_labels = np.array(train_set['religion'])

    validation_set = validation_data[region]
    validation_images = np.array(validation_set['image'].tolist()) / 255.0
    validation_labels = np.array(validation_set['religion'])

    test_set = test_data[region]
    test_images = np.array(test_set['image'].tolist()) / 255.0
    test_labels = np.array(test_set['religion'])

    train_labels = to_categorical(train_set['religion'], num_classes=8)
    validation_labels = to_categorical(validation_set['religion'], num_classes=8)
    test_labels = to_categorical(test_set['religion'], num_classes=8)

    print(f"Jedinstvene oznake vrednosti za {region}: {[RELIGION_MAPPING[label] for label in sorted(train_set['religion'].unique())]}")

    # Treniranje modela sa većim brojem epoha i validacionim podacima
    history = model.fit(train_images, train_labels, epochs=20, batch_size=32, validation_data=(validation_images, validation_labels))

    # Postavljanje veličine figure
    plt.figure(figsize=(12, 5))

    # Plot tačnosti
    plt.subplot(1, 2, 1)
    plt.plot(history.history['accuracy'], label='Tačnost treniranja', color='blue', linewidth=2)
    plt.plot(history.history['val_accuracy'], label='Tačnost validacije', color='orange', linewidth=2)
    plt.xlabel('Epoha', fontsize=14)
    plt.ylabel('Tačnost', fontsize=14)
    plt.legend(loc='upper right', fontsize=12)
    plt.title('Tačnost modela tokom treniranja', fontsize=16)
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.ylim([0, 1])

    # Plot gubitka
    plt.subplot(1, 2, 2)
    plt.plot(history.history['loss'], label='Gubitak treniranja', color='blue', linewidth=2)
    plt.plot(history.history['val_loss'], label='Gubitak validacije', color='orange', linewidth=2)
    plt.xlabel('Epoha', fontsize=14)
    plt.ylabel('Gubitak', fontsize=14)
    plt.legend(loc='upper right', fontsize=12)
    plt.title('Gubitak modela tokom treniranja', fontsize=16)
    plt.grid(True, linestyle='--', alpha=0.7)

    plt.tight_layout(pad=3)
    plt.show()

    # Evaluacija modela
    test_loss, test_acc = model.evaluate(test_images, test_labels)
    print(f'Test tačnost za {region}: {test_acc:.2f}')

    # Predikcije na test podacima
    predictions = model.predict(test_images)
    predicted_labels = np.argmax(predictions, axis=1)

    # Ispis stvarnih i predviđenih religija za svaki test podatak
    print(f"{'Test Uzorak':>15} | {'Zemlja':>20} | {'Stvarna Religija':>20} | {'Predviđena Religija':>20}")
    print("-" * 90)
    for i in range(len(test_labels)):
        actual_religion = RELIGION_MAPPING[test_set.iloc[i]['religion']]
        predicted_religion = RELIGION_MAPPING[predicted_labels[i]]

        # Pronalaženje naziva države za odgovarajući test uzorak
        country_name = test_set.iloc[i]['name']

        print(f"{i+1:>15} | {country_name:>20} | {actual_religion:>20} | {predicted_religion:>20}")
    print()

# Srđan Garić IN47/2021 CSV

import pandas as pd
import numpy as np
import random
import matplotlib.pyplot as plt
import tensorflow as tf
from keras.models import Sequential
from keras.layers import Dense, Dropout, BatchNormalization
from keras.initializers import glorot_uniform
from keras.regularizers import l2
from keras.callbacks import EarlyStopping
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

SEED = 42
random.seed(SEED)
np.random.seed(SEED)
tf.random.set_seed(SEED)

# Putanja do CSV-a
FLAGS_CSV_PATH = 'flags_csv/flag.data'

# Učitavanje podataka iz CSV-a
df = pd.read_csv(FLAGS_CSV_PATH, names=[
    'name', 'landmass', 'zone', 'area', 'population', 'language',
    'religion', 'bars', 'stripes', 'colours', 'red', 'green', 'blue',
    'gold', 'white', 'black', 'orange', 'mainhue', 'circles', 'crosses',
    'saltires', 'quarters', 'sunstars', 'crescent', 'triangle', 'icon',
    'animate', 'text', 'topleft', 'botright'
])

# Mapiranje boja
COLOR_MAPPING = {
    'green': '0',
    'red': '1',
    'blue': '2',
    'gold': '3',
    'white': '4',
    'black': '5',
    'orange': '6',
    'brown': '7'
}

df['mainhue'] = df['mainhue'].map(COLOR_MAPPING)
df['topleft'] = df['topleft'].map(COLOR_MAPPING)
df['botright'] = df['botright'].map(COLOR_MAPPING)

# Uklanjanje kolone 'name'
df.drop(columns=['name'], inplace=True)

# Podela podataka na karakteristike i ciljnu varijablu
X = df.drop(columns=['religion'])
y = df['religion']

# Podela podataka na trening, validacioni i test skup
X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.2, random_state=SEED)
X_validation, X_test, y_validation, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=SEED)

# Standardizacija karakteristika
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_validation = scaler.transform(X_validation)
X_test = scaler.transform(X_test)

# Definisanje modela neuronske mreže
model = Sequential()
model.add(Dense(512, input_dim=X_train.shape[1], activation='relu', kernel_initializer=glorot_uniform(seed=SEED), kernel_regularizer=l2(0.001)))
model.add(BatchNormalization())
model.add(Dropout(0.5))
model.add(Dense(256, activation='relu', kernel_initializer=glorot_uniform(seed=SEED), kernel_regularizer=l2(0.001)))
model.add(BatchNormalization())
model.add(Dropout(0.5))
model.add(Dense(128, activation='relu', kernel_initializer=glorot_uniform(seed=SEED), kernel_regularizer=l2(0.001)))
model.add(BatchNormalization())
model.add(Dropout(0.5))
model.add(Dense(8, activation='softmax', kernel_initializer=glorot_uniform(seed=SEED)))

# Kompajliranje modela
model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# Treniranje modela
history = model.fit(X_train, y_train, validation_data=(X_validation, y_validation), epochs=20, verbose=1)

# Evaluiranje modela na test skupu
test_loss, test_accuracy = model.evaluate(X_test, y_test)
print(f'Test Accuracy: {test_accuracy}')

# Prikaz tačnosti i gubitka tokom treninga, validacije i testiranja
plt.figure(figsize=(12, 5))

# Prikaz tačnosti
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Tačnost treniranja', color='blue', linewidth=2)
plt.plot(history.history['val_accuracy'], label='Tačnost validacije', color='orange', linewidth=2)
plt.xlabel('Epoha', fontsize=14)
plt.ylabel('Tačnost', fontsize=14)
plt.legend(loc='upper right', fontsize=12)
plt.title('Tačnost modela tokom treniranja', fontsize=16)
plt.grid(True, linestyle='--', alpha=0.7)
plt.ylim([0, 1])

# Prikaz gubitka
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Gubitak treniranja', color='blue', linewidth=2)
plt.plot(history.history['val_loss'], label='Gubitak validacije', color='orange', linewidth=2)
plt.xlabel('Epoha', fontsize=14)
plt.ylabel('Gubitak', fontsize=14)
plt.legend(loc='upper right', fontsize=12)
plt.title('Gubitak modela tokom treniranja', fontsize=16)
plt.grid(True, linestyle='--', alpha=0.7)

plt.tight_layout(pad=3)
plt.show()